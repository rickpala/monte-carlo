# -*- coding: utf-8 -*-
"""high precision overnight run.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DfGKgBm6v2rKh3L2jvkEOUBmGqiPQ2Ud
"""

#-- Packages --#
import random
import math
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import sys
from tqdm import tqdm
from collections import Counter
from pprint import pprint
from multiprocessing import Pool, Process, Value, Array

class Point:
  """
  A point that takes a random walk.

  The point lives on a lattice, where each point is referenced
  by xv[i,j] and yv[i,j]. It can walk() one step in 2-D and also check
  if it's out_of_bounds().
  """
  def __init__(self, i, j, xv, yv, oob=False):
    self.i = i
    self.j = j
    self.xv = xv
    self.yv = yv
    self.x = self.xv[i, j]
    self.y = self.yv[i, j]
    self.oob = oob # out-of-bounds (False by default)
    self.path = [(self.x, self.y)] # List of x,y points taken
  
  def __str__(self):
    return f"({self.x}, {self.y})"

  def draw_walk(self):
    blue2red = [plt.cm.jet(i/steps) for i in range(steps)]
    fig, ax = plt.subplots(1, figsize=(12, 12))
    ax.scatter([u[0] for u in p.path], [u[1] for u in p.path], 
                 alpha=0.05, lw=0.1, c=blue2red)
    ax.set_xlim(xv[0, 0], xv[-1, -1])
    ax.set_ylim(yv[0, 0], yv[-1, -1])
    fig.show()

  def rand_walk(self, show_graph=False):
    """Performs one random walk starting at lattice indices (i,j) until a boundary is met."""
    result = 0

    while not self.out_of_bounds():
      self.step()
    steps = len(p.path)
    
    if show_graph:
      self.draw_walk()
    return p

  def step(self):
    """Take a step in 2-D and track the newly updated coordinates."""
    dir = random.choice([[0, 1], [0, -1],  # Up, Down
                         [1, 0], [-1, 0]]) # Right, Left
    self.i += dir[0]
    self.j += dir[1]
    self.track_new_point(self.i, self.j)

  def track_new_point(self, i, j):
    """Appends the latest x-y coordinates to `path`"""
    if self.out_of_bounds():
      return  # Prevent array index out-of-bounds
    self.x = self.xv[i, j]
    self.y = self.yv[i, j]
    self.path.append((self.x, self.y))

  def out_of_bounds(self):
    return (self.x <= 0 or
            self.x >= 7 or
            self.y <= 0 or
            self.y >= 9)

    # return (self.i <= 0 or
    #         self.i >= self.xv.shape[0] or
    #         self.j <= 0 or
    #         self.j >= self.yv.shape[1])

class Solver:
  def __init__(self):
    # make lattice
    # initial conditions
    # read from csv/json
    pass

  def make_lattice(dpi=1):
    h, v = 7, 9    # inches
    n_points = 10  # lattice points from 0 to 1
    nx, ny = np.array([h*n_points, v*n_points])
    unc = int(np.round(np.log10(n_points)))
    x = np.linspace(0, h, nx+1) # keeps points uniform (+1)
    y = np.linspace(0, v, ny+1)
    xv, yv = np.meshgrid(x, y, indexing="ij")
    # Comment for my understanding of meshgrid (Joey): Creates 2 matrices, 
    # xv and yv, whereby the same i,j element of each matrix represents the
    # corresponding (x,y) of this hypothetical grid (stores (i,j) instead with
    # indexing argument)
    return xv, yv

  def generate_ic(self, walks_per_point=1, num_processes=16):
    """Generates initial conditions from self.lattice"""
    ic = []
    for i in range(nx+1):  # +1 -> (i, j)*n_points = (x, y)
      for j in range(ny+1):  # +1 -> (i, j)*n_points = (x, y)
        for _ in range(walks_per_point):
          ic.append((i, j))
    self.ic = ic
  def solve(self, point, *args):
    
  def perform_walks(self, walks_per_point, processes=0):
      if processes > 0:  # run in parallel
        with Pool(num_processes) as pool:
          rv = pool.starmap(rand_walk, tqdm(ic, total=len(ic)), chunksize=16)
        return rv
      else:  # run sequentially
        return [for cond in self.ic]

    pass

  def draw_solution(self, style="contour", filepath=None, img_idx=0)
    # style="contour", "surface"
    fig, ax = plt.subplots(figsize=(8, 8))
    steps = len(p.path)
    blue2red = [plt.cm.jet(i/steps) for i in range(steps)]
    ax.scatter([u[0] for u in p.path], [u[1] for u in p.path], 
                  alpha=0.25, lw=1, c=blue2red)
    ax.scatter(xv, yv, alpha=0.15, lw=1, c='gray')
    ax.set_xlim(p.xv[0, 0], p.xv[-1, -1])
    ax.set_ylim(p.yv[0, 0], p.yv[-1, -1])

    if filepath:
      fig.savefig(f"test{img_idx}", dpi=300)
  
  def agg_data(self):
    pass
    

# save 10 random walks
for i in range(10):
  n_walks = len(star)
  p = star[random.randint(0, n_walks)]
  create_walkfig(p, save=True, img_idx=i)

# Dataframe Code #

# Function which aggregates data from each RW to dataframe
def agg_data(path,df):
  # does path end on non-trivial boundary?
  ends_nontrivial = (path[-1][1] == v)

  # count the visits to each point in a RW (ask if this really works)
  path = [(float(f"{x:.1f}"), float(f"{y:.1f}")) for x, y in path]
  count = Counter(path)
  
  # insert visits into DataFrame and insert BC of path (and sub-paths)
  for elem in count.elements():
    ind = np.where(pts == str(elem)) # find index with this pt
    df['Visits'][ind[0][0]] = df['Visits'][ind[0][0]] + count[elem]

    # if overall path goes to non-trivial boundary, for each elem/pt in path, add visits to that pt from each sub-walk, to the number of RWs (including sub-walks obviously) that end on non-trivial boundary visits
    if ends_nontrivial:
      df['Non-trivial boundary visits'][ind[0][0]] = df['Non-trivial boundary visits'][ind[0][0]] + count[elem]

  return df


# Pts on lattice (let me know if easier way to obtain; either way it fast)
pts = []
for i in x:
  for j in y:
    # pts = np.append(pts,"("+str(np.round(i,unc))+", "+str(np.round(j,unc))+")")
    pts = np.append(pts, f"({np.round(i, unc)}, {np.round(j, unc)})")

# Initialize dataframe
visits = np.zeros(len(pts))
bound_visits = np.zeros(len(pts))
d = {'(x,y)': pts, 'Visits': visits, 'Non-trivial boundary visits': bound_visits}
df = pd.DataFrame(data=d)
print("Initial Dataframe")
print(df)

# Create dataframe
print("Extracting data from "+str(len(star))+" random walks")
for p in tqdm(star):
  df = agg_data(p.path,df)


# Full dataframe
print("Full Dataframe")
print(df)

# MUST figure out way to parallelize this!!!!!!

# Plot Solution using dataframe
def Phi(x, y):
    pt = "("+str(np.round(x,unc))+", "+str(np.round(y,unc))+")"
    ind = np.where(df['(x,y)'] == pt)

    return (12*df['Non-trivial boundary visits'][ind[0][0]])/(df['Visits'][ind[0][0]])


phi = np.zeros((len(xv), len(xv[0])))
for i in range(len(x)):
  for j in range(len(y)):
    phi[i][j] = Phi(x[i],y[j])

fig = plt.figure()
ax = plt.axes(projection='3d')
ax.contour3D(xv, yv, phi, 50, cmap='rainbow')
ax.set_xlabel('x [inches]')
ax.set_ylabel('y [inches]')
ax.set_zlabel('\u03A6 [Volts]');

# Surface Plot
fig = plt.figure()
ax = plt.axes(projection='3d')
ax.plot_surface(xv, yv, phi, cmap='rainbow', linewidth=0)
ax.set_xlabel('x [inches]')
ax.set_ylabel('y [inches]')

# Equipotential (2D) Plot
# Must be 1V intervals!!! (find where Phi exactly equals 0, 1, ..., 12)

fig = plt.figure()
contours = plt.contour(xv, yv, phi, 13, cmap='rainbow', linewidth=0)
plt.clabel(contours, inline=True, fontsize=8)
plt.xlabel('x [inches]')
plt.ylabel('y [inches]')

"""Theory behind approximating $\Phi(x,y)$ using random walks: (explain WHY $\Phi(x_k,y_k) \approx \sum_{i=1}^{n} g_i\mathbb{P}(x_i,y_i)$ LATER; involves proof using FDEs)

${}$

Given $n = 2(n_x + n_y) - 4$ boundary points on the lattice ($n_x$ by $n_y$ points), $\Phi(x_k,y_k)$ for some 'starting point' on the lattice $(x_k,y_k)$, can be approximated as $\Phi(x_k,y_k) \approx \sum_{i=1}^{n} g_i\mathbb{P}(x_i,y_i)$, where $g_i$ is the value of $\Phi$ at the ith boundary point (either $0$ or $12$), and $\mathbb{P}(x_i,y_i)$ is the probability of the random walk (RW) ending at that boundary point. It is the latter which must be found through computational experimentation, however, some more simplifications can be done.

Considering an experiment of N RWs with the same starting point $(x_A, y_A)$, the probability of one of those RWs landing on the boundary indexed by $i$ is $\frac{N_i}{N}$, where $N_i$ is the number of RWs that end on that boundary. The approximation of the solution for that starting point can then be written as $\Phi(x_A,y_A) \approx \frac{1}{N}\sum_{i=1}^{n} g_i N_i$. After the first R,W which ends at one of the boundaries $i'$, $\Phi(x_A,y_A) \approx g_{i'}$. After the second RW, which could either end at $i'$ or a new boundary $j'$, $\Phi(x_A,y_A) \approx \frac{1}{2}(g_{i'} + g_{j'})$ (if it lands on the same boundary, i.e. $j' = i'$, it becomes $\frac{1}{2}(g_{i'} + g_{i'}) = g_{i'}$. The overall pattern is that for each RW, obviously $N$ goes up by 1, but what also changes is another $g_i$ is added (whether it be the same boundary or a different one). Algorithmically, this means after $N$ RWs, $\Phi(x_A,y_A) \approx \frac{1}{N}\sum_{RW} g_i$; i.e. for each RW, get the $g_i$ from one of the $n$ boundaries that the RW lands on, and keeping adding them (then normalzie by the number of RWs $N$). 

${}$

In addition, every RW has some number of steps $N_S$ it takes to reach a boundary. By recursion, all $N_S$ points visited on this random walk can be considered as a 'subwalk', each having different starting points. Therefore, one walk of size $N_S$ has $N_S$ random walks with $N_S$ different starting points $(x_k,y_k)$, where $k$ goes from $1$ to $N_S$.

On one random walk, the outcome for each subwalk will be identical (the same boundary is landed on, and therefore the same $g_i$), but each will approximate the value $\Phi$ at different starting points. If a walk ends at the boundary with 12V, for example, then each subwalk will have the same outcome. This lets us recycle information gained from one random walk by a factor of $N_S$.

By including the sub-walks into the original equation approximating $\Phi$ involving just the number of RWs, $N$ becomes the overall number of 'visits' to that point (which in general is a lot more than $N$ because each visit gives a new sub-walk). $\Phi(x_k,y_k) \approx \frac{1}{N}\sum_{RW} g_i$ for each starting point $k$ on the lattice. To simplify further in terms of the problem, there is only one non-trivial boundary condition (12V), which means it amounts to find the number of visits to the non-trivial boundary (the number of times a RW, including sub-walks, ends on the non-trivial boundary) instead of doing the whole sum, and mutiplying this by the non-trivial boundary value of 12V. Overall, $\Phi(x_k,y_k) \approx \frac{12B_k}{N_k}$ where $N_k$ is the number of visits to the kth point on the lattice, and $B_k$ is the number of visits to the non-trivial boundary 12V. Doing this procedure also allows us to retrieve more information from each RW. 

(Ask Ricky if description above works better... its more in-depth but may be a bit too wordy and the prof may lose attention... if so delete paragraph below) 

We can approximate the value of $\Phi(x_k, y_k)$ by analyzing all the walks that visit that specific $(x_k,y_k)$ pair and the proportion that end at the nontrivial boundary (12V). Overall, this allows us to retrieve more information from each RW. 

Note that there could be overlap of starting points, but either way they are different RWs.

<table>
  <tr>
    <th>x</th>
    <th>y</th>
    <th>Visits</th>
    <th>Nontrivial Boundary Visits</th>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>1103</td>
    <td>978</td>
  </tr>
  <tr>
    <td>1</td>
    <td>2</td>
    <td>978</td>
    <td>865</td>
  </tr>
  <tr>
    <td>1</td>
    <td>3</td>
    <td>1045</td>
    <td>917</td>
  </tr>
  <tr>
    <td>1</td>
    <td>4</td>
    <td>1402</td>
    <td>1208</td>
  </tr>
    <tr>
    <td>...</td>
    <td>...</td>
    <td>...</td>
    <td>...</td>
  </tr>
</table>
"""

if __name__ == "__main__":
    solve()
